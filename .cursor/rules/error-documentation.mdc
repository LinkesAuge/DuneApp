---
description: Document major failure points in this project and they were solved.  To be filled by AI.
globs: 
alwaysApply: true
---
# Error Documentation: Dune Awakening Deep Desert Tracker

This document tracks known issues, their states, context, and resolutions encountered during the development of the Dune Awakening Deep Desert Tracker project.

## Format for Entries

-   **Date**: YYYY-MM-DD
-   **Error Description**: A clear summary of the error.
-   **Context/Symptoms**: How and where the error manifested.
-   **Investigation/Diagnosis**: Steps taken to understand the root cause.
-   **Solution/Fix**: The implemented solution.
-   **Files Affected**: List of files changed.
-   **Lesson Learned**: Key takeaway to prevent recurrence.

--- 

*(No errors documented yet.)*

---

-   **Date**: 2025-01-28
-   **Error Description**: POI image cropping system issues - free mode tool preselected, cropping from already-cropped images instead of originals, and missing database schema for original/cropped image handling.
-   **Context/Symptoms**: 
    1. When opening POI edit modal for image cropping, "Free Form" tool was automatically preselected when user wanted no tool active by default
    2. When editing existing POI images that were previously cropped, subsequent crops were applied to the already-cropped image instead of the original image
    3. Original images were being lost during the upload/crop workflow because only cropped versions were saved
    4. Database schema was missing `original_url` and `crop_details` fields in PoiScreenshot interface, causing TypeScript errors and runtime issues
-   **Investigation/Diagnosis**:
    -   **Tool Preselection**: ImageCropModal was using `aspect=undefined` for "no tool active" state, but this was being interpreted as "Free Form" active. Needed a distinct state for "no tool selected".
    -   **Original Image Loss**: The `PendingScreenshotFile` interface only stored the final processed file, losing the original when cropping was applied. When editing existing screenshots, the system tried to access `original_url` but this field wasn't properly stored.
    -   **Database Schema Gap**: The PoiScreenshot interface was missing `original_url` and `crop_details` fields that the code was trying to use, creating a mismatch between implementation and types.
    -   **Upload Workflow Flaw**: The current workflow immediately replaced the original file with the cropped version, making it impossible to re-crop from the original or store both versions properly.
-   **Solution/Fix**:
    1.  **Fixed Tool Selection State Management**: Modified ImageCropModal to use `aspect=null` for "no tool active", `aspect=undefined` for "Free Form", and `aspect=1` for "Square Mode". Updated button styling logic accordingly.
    2.  **Enhanced Database Schema**: Added `original_url?: string | null` and `crop_details?: PixelCrop | null` fields to PoiScreenshot interface with proper import from 'react-image-crop'.
    3.  **Redesigned Upload Workflow**: Completely overhauled the PendingScreenshotFile interface to store both `originalFile` and `displayFile`, preserving the original throughout the entire workflow.
    4.  **Fixed Upload Logic**: Modified the upload process to save both original and display versions to separate storage paths (`poi_originals/` and `poi_screenshots/`) with proper URL references.
    5.  **Improved Image Preview**: Changed ImageCropModal image constraint from `max-h-[60vh]` to `max-h-full` to better utilize available space for tall images.
-   **Files Affected**:
    -   `src/components/grid/ImageCropModal.tsx` (Tool selection state and image sizing)
    -   `src/types/index.ts` (Enhanced PoiScreenshot interface)
    -   `src/components/hagga-basin/POIEditModal.tsx` (Complete workflow overhaul)
-   **Lesson Learned**: When implementing image cropping systems: (1) Always preserve original files separately from processed versions, (2) Use distinct state values for different UI modes rather than relying on undefined/truthy checks, (3) Ensure database schema matches the data structures used in code, (4) Design upload workflows to handle both original and processed versions from the start rather than retrofitting later, (5) Test image cropping workflows with both new uploads and editing existing images to catch different code paths.

---

-   **Date**: YYYY-MM-DD <!-- User should replace with current date -->
-   **Error Description**: Supabase Storage `listBuckets()` returns empty array `[]` and `getBucket('bucket-name')` fails with "Bucket not found" (400 error) for a newly created, public bucket, despite the bucket existing in the Supabase dashboard and client being authenticated.
-   **Context/Symptoms**: Occurred in `PoiTypeManager.tsx` when attempting to interact with a new 'poi-icons' bucket for icon uploads. Another existing bucket ('screenshots') was working for other functionalities. SQL grants for `SELECT` on `storage.buckets` to `authenticated` and `anon` roles did not resolve the issue. No restrictive RLS policies were found on `storage.buckets` table itself.
-   **Investigation/Diagnosis**:
    -   Verified bucket existence and public status in Supabase dashboard.
    -   Confirmed client-side Supabase initialization and user authentication.
    -   Ran `supabase.storage.listBuckets()` directly in component, consistently received `[]`.
    -   Ran `supabase.storage.getBucket('poi-icons')`, received 400 error.
    -   Applied various SQL `GRANT` statements for `storage.buckets`, `storage.objects`, `storage.migrations` and `USAGE` on `storage` schema to `authenticated` and `anon` roles.
    -   Checked for RLS policies on `storage.buckets` (none found).
    -   The exact root cause for `listBuckets()` returning empty for a specific, seemingly correctly configured bucket remained elusive, suggesting potential subtle configuration issues or caching on Supabase's side that weren't immediately apparent.
-   **Solution/Fix**: 
    1.  Decided to use an existing, functional bucket ('screenshots') and create a dedicated subfolder ('icons/') within it for POI icons.
    2.  Refactored `PoiTypeManager.tsx` to upload icons to `screenshots/icons/` and removed direct calls to `listBuckets()` or `getBucket()` that were causing issues, relying on known bucket and path.
-   **Files Affected**:
    -   `src/components/admin/PoiTypeManager.tsx` (Primary change to use different bucket/path and remove failing Storage calls)
    -   Initially, SQL scripts for creating 'poi-icons' bucket and its policies (later made redundant by the workaround).
-   **Lesson Learned**: When encountering unexplained issues with new Supabase Storage buckets (especially `listBuckets()` or `getBucket()`), and if an existing bucket is functional, consider using a subfolder within the working bucket as a pragmatic workaround to avoid prolonged debugging of potential platform-side intricacies. Always verify RLS policies and grants thoroughly, but be prepared for alternative strategies if issues persist.

---

-   **Date**: YYYY-MM-DD <!-- User should replace with current date -->
-   **Error Description**: `pg_cron` job fails to trigger Supabase Edge Function; `cron.job_run_details` shows `return_message` like "ERROR: schema \"net\" does not exist".
-   **Context/Symptoms**: Scheduled tasks (e.g., `perform-map-backup`) that rely on `pg_cron` to call a Supabase Edge Function via `net.http_post` were not executing the function. The cron job itself might appear to run, but the target function logs no invocations.
-   **Investigation/Diagnosis**:
    -   Checked `cron.job` for job definition and `cron.job_run_details` for execution status and return messages.
    -   The error "schema \"net\" does not exist" in `return_message` clearly indicated the `pg_net` PostgreSQL extension was missing or not enabled.
    -   Verified in Supabase Dashboard under Database > Extensions that `pg_net` was not listed or not enabled.
-   **Solution/Fix**:
    1.  Enabled the `pg_net` extension by running the following SQL in the Supabase SQL Editor:
        ```sql
        CREATE EXTENSION IF NOT EXISTS pg_net WITH SCHEMA extensions;
        ```
-   **Files Affected**: None (Database configuration change).
-   **Lesson Learned**: `pg_net` is a critical dependency for `pg_cron` to trigger Supabase Edge Functions using `net.http_post`. If scheduled function invocations fail, always check `cron.job_run_details` for errors and ensure `pg_net` is enabled in the database. Add this to `docs/technical.md`.

---

-   **Date**: YYYY-MM-DD <!-- User should replace with current date -->
-   **Error Description**: User deletion via Supabase Edge Function (`delete-user`) calling `supabase.auth.admin.deleteUser()` failed with the error "Failed to delete user from authentication: Database error deleting user".
-   **Context/Symptoms**: Occurred in the Admin Panel when attempting to delete a user. The Edge Function logs showed the error originating from the `deleteUser()` call.
-   **Investigation/Diagnosis**:
    -   Initial assumption was a direct issue with the `auth.users` table or the `deleteUser` admin function.
    -   Used SQL to query `pg_constraint` to identify foreign key relationships involving `auth.users`.
    -   Discovered that `public.profiles.id` had a foreign key constraint (`profiles_id_fkey`) referencing `auth.users(id)` with an `ON DELETE NO ACTION` policy. This prevented the `auth.users` row from being deleted because a dependent row existed in `public.profiles`.
    -   Further checked for foreign keys referencing `public.profiles(id)` from other tables (e.g., `pois`, `grid_squares`) to ensure no further downstream blocking issues once the `profiles` row was deleted. In this case, no further blocking constraints were found on other public tables.
-   **Solution/Fix**:
    1.  Modified the `profiles_id_fkey` constraint on the `public.profiles` table to use `ON DELETE CASCADE`.
        ```sql
        -- 1. Drop the existing constraint
        ALTER TABLE public.profiles
        DROP CONSTRAINT profiles_id_fkey;

        -- 2. Add it back with ON DELETE CASCADE
        ALTER TABLE public.profiles
        ADD CONSTRAINT profiles_id_fkey FOREIGN KEY (id)
        REFERENCES auth.users (id) ON DELETE CASCADE;
        ```
-   **Files Affected**:
    -   Database schema (constraint modification).
    -   `docs/technical.md` (updated to document this common issue and solution).
-   **Lesson Learned**: When deleting from `auth.users` in Supabase, always verify the `ON DELETE` action of any foreign key constraints in `public` tables (especially `public.profiles`) that reference `auth.users.id`. `NO ACTION` or `RESTRICT` will cause deletion failures. Change to `CASCADE` or `SET NULL` as appropriate for the data model. Also, check for chained dependencies if other tables reference the `profiles` table.

---

-   **Date**: YYYY-MM-DD <!-- User should replace with current date -->
-   **Error Description**: Scheduled map reset (with "backup before reset" enabled) successfully performed the backup but then failed to delete data from `pois` and `grid_squares` tables.
-   **Context/Symptoms**: The Supabase Edge Function log for `perform-map-reset` showed the error: `Failed to delete POIs: invalid input syntax for type uuid: "0"`. This occurred because the delete operation was attempting `supabaseAdmin.from('pois').delete().neq('id', '0')` where the `id` column is of type UUID, and '0' is not a valid UUID string.
-   **Investigation/Diagnosis**: Examined the `perform-map-reset/index.ts` function. Identified the `.neq('id', '0')` filter in the delete operations for both `pois` and `grid_squares` tables as the cause of the type mismatch.
-   **Solution/Fix**: Modified `supabase/functions/perform-map-reset/index.ts`. Changed the Supabase query filter for deleting records from `.delete().neq('id', '0')` to `.delete().not('id', 'is', null)` for both `pois` and `grid_squares` tables. This provides a type-safe way to target all rows for deletion, assuming the `id` column is a primary key and thus never null for existing rows.
-   **Files Affected**:
    -   `supabase/functions/perform-map-reset/index.ts`
-   **Lesson Learned**: When attempting to delete all rows in a table using the Supabase query builder with a filter (e.g., `.delete().filter(...)`), ensure the filter condition is type-compatible with the column(s) involved. For UUID primary keys, using a condition like `.not('id', 'is', null)` is a robust and type-safe method to target all rows for deletion. Avoid direct string comparisons with UUID columns unless the string is a valid UUID.

---

-   **Date**: 2025-01-03
-   **Error Description**: Custom icons not displaying on map - POIs showed custom icons in edit modals but reverted to default POI type icons (emojis) when displayed on the map.
-   **Context/Symptoms**: 
    -   Console logs showed MapPOIMarker receiving emoji icons ("ðŸ”°", "ðŸ”²", "ðŸ›¡ï¸") instead of custom icon UUIDs
    -   POIEditModal correctly processed custom icon selection (UUID: "888361ee-62fd-4b50-b408-cd00644b86b8")
    -   Custom icon selections didn't persist through database operations and component re-renders
    -   Map components consistently showed POI type default icons instead of user-selected custom icons
-   **Investigation/Diagnosis**:
    -   Root cause identified as client-side data modification approach in POI modals
    -   POIEditModal and POIPlacementModal were temporarily modifying POI type data client-side
    -   Database operations saved POI records without custom icon references
    -   Map components received POI data through database queries, losing client-side modifications
    -   This created a disconnect between edit interface (showing custom icons) and display interface (showing defaults)
-   **Solution/Fix**:
    1.  **Database Schema Enhancement**: Added `custom_icon_id uuid` column to `pois` table with foreign key to `custom_icons(id)` and `ON DELETE SET NULL`
    2.  **TypeScript Interface Update**: Modified `Poi` interface to include `custom_icon_id: string | null`
    3.  **Component Logic Overhaul**: Updated all POI-related components to use database-first approach:
        -   **MapPOIMarker**: Modified `getDisplayImageUrl` to check POI's `custom_icon_id` first, then POI type defaults
        -   **POIEditModal & POIPlacementModal**: Changed from client-side override to database persistence, saving `custom_icon_id` directly
        -   **HaggaBasinPoiCard**: Updated icon rendering to use same priority logic as MapPOIMarker
        -   **PoiCard**: Added `customIcons` prop and updated icon rendering for Deep Desert POIs
        -   **PoiList**: Added `customIcons` prop passthrough to PoiCard
        -   **GridSquareModal**: Added custom icons fetching and state management
    4.  **Database Migration**: Created and executed migration script with indexing for performance
-   **Files Affected**:
    -   Database: `add_custom_icon_id_column.sql`
    -   Types: `src/types/index.ts`
    -   Map Components: `src/components/hagga-basin/MapPOIMarker.tsx`
    -   Edit Modals: `src/components/poi/POIEditModal.tsx`, `src/components/poi/POIPlacementModal.tsx`
    -   Display Components: `src/components/hagga-basin/HaggaBasinPoiCard.tsx`, `src/components/poi/PoiCard.tsx`, `src/components/poi/PoiList.tsx`, `src/components/grid/GridSquareModal.tsx`
-   **Lesson Learned**: For persistent user selections that need to survive database operations and component re-renders, always use a database-first approach rather than client-side data modification. Client-side overrides are fragile and don't persist through data refresh cycles. Database persistence with proper foreign key relationships ensures data integrity and consistent display across all application interfaces.

---

-   **Date**: 2025-01-03
-   **Error Description**: POI filter All/None toggle buttons not working correctly - "Hide All" would briefly hide POIs but immediately show them again, and overall filtering logic was inconsistent.
-   **Context/Symptoms**: 
    -   User reported that All/None filter buttons still didn't work after previous attempts to fix them
    -   "Hide All" button would update the UI but POIs would remain visible on the map
    -   Console debugging showed state changes happening correctly but visual results were wrong
    -   Toggle button text was updating properly but actual POI visibility wasn't responding
-   **Investigation/Diagnosis**:
    -   **Root Cause 1 - Filtering Logic Bug**: The condition `if (selectedPoiTypes.length > 0 && !selectedPoiTypes.includes(poi.poi_type_id))` had a fatal flaw:
        - When `selectedPoiTypes` was empty (Hide All state), the first part `selectedPoiTypes.length > 0` was false
        - This made the entire condition false, causing all POIs to be shown instead of hidden
        - The logic was backwards for the "Hide All" scenario
    -   **Root Cause 2 - State Management Conflict**: A useEffect was automatically re-selecting all POI types whenever `selectedPoiTypes.length === 0`:
        - This was intended for initial page load setup but triggered on every state change
        - When user clicked "Hide All" â†’ `selectedPoiTypes` became empty â†’ useEffect immediately refilled it â†’ user action was undone
        - Created a race condition between user actions and automatic state management
-   **Solution/Fix**:
    1.  **Fixed Core Filtering Logic**: Changed condition to `if (!selectedPoiTypes.includes(poi.poi_type_id))`:
        - Simplified logic that works correctly for both show and hide scenarios
        - When `selectedPoiTypes` is empty â†’ no POIs pass the filter â†’ all hidden (correct)
        - When `selectedPoiTypes` has values â†’ only included POIs pass â†’ only selected shown (correct)
    2.  **Fixed State Management**: Added `initialFilterSetup` flag to control useEffect:
        - Effect only runs once on initial page load when `!initialFilterSetup`
        - Prevents interference with user actions after initial setup
        - Preserves user's filter choices without automatic override
    3.  **Console Cleanup**: Removed debug logs from `useMapSettings`, `SignInForm`, and `supabase.ts` for production readiness
-   **Files Affected**:
    -   `src/pages/HaggaBasinPage.tsx` (Primary fix - filtering logic and state management)
    -   `src/lib/useMapSettings.ts` (Removed console logs)
    -   `src/components/auth/SignInForm.tsx` (Removed console logs)
    -   `src/lib/supabase.ts` (Removed console logs)
-   **Lesson Learned**: Complex filtering logic with multiple conditions can create edge cases where the logic works for some scenarios but fails for others. When debugging filter systems: (1) Test all possible states including empty selections, (2) Watch for useEffect hooks that might interfere with user actions, (3) Simplify filtering conditions to avoid edge case failures, (4) Use state flags to control when automatic effects should run vs. when user actions should take precedence. Always verify that "hide all" and "show all" scenarios work correctly in filtering systems.

---

-   **Date**: 2025-01-28
-   **Error Description**: POI image cropping modal issues - square mode preselected when editing images and tall images getting cut off in preview.
-   **Context/Symptoms**: 
    -   When editing already cropped POI images (especially those with height > width), the square cropping tool was automatically preselected
    -   Tall images appeared very small or "cut off" in the cropping modal preview, making it difficult to see and select the desired crop area
    -   Users expected no cropping tool to be preselected by default when editing POI images
    -   The preview area wasn't utilizing available space efficiently for tall images
-   **Investigation/Diagnosis**:
    -   **Root Cause 1 - Square Mode Preselection**: In `POIEditModal.tsx`, the `ImageCropModal` was called with `defaultToSquare={true}`, automatically activating square mode regardless of user preference
    -   **Root Cause 2 - Image Preview Height Constraint**: In `ImageCropModal.tsx`, the image had CSS class `max-h-[60vh]` which limited height to 60% of viewport height. For tall images, this constraint was too restrictive given the available space in the modal's image area
    -   The modal itself was `max-h-[90vh]` and the image area used `flex-grow`, but the fixed 60vh limit on the image prevented it from using the full available space
-   **Solution/Fix**:
    1.  **Fixed Square Mode Preselection**: Changed `defaultToSquare={true}` to `defaultToSquare={false}` in `POIEditModal.tsx` line 1000
    2.  **Improved Image Preview Sizing**: Changed image CSS from `max-h-[60vh]` to `max-h-full` in `ImageCropModal.tsx` line 391, allowing images to use the full height of their flex container
    -   This allows tall images to display much larger while still fitting within the modal's responsive layout
    -   The flex container with `flex-grow` and `overflow-hidden` properly constrains the image to available space
-   **Files Affected**:
    -   `src/components/hagga-basin/POIEditModal.tsx` (Changed defaultToSquare prop)
    -   `src/components/grid/ImageCropModal.tsx` (Improved image sizing CSS)
-   **Lesson Learned**: When implementing cropping modals: (1) Don't preselect cropping tools unless there's a specific business requirement - let users choose their preferred method, (2) Use flexible CSS constraints (like `max-h-full`) that work with flex layouts rather than fixed viewport units that may not utilize available space efficiently, (3) Consider the aspect ratio and available space when constraining image previews - tall images need more height allowance than fixed vh units typically provide.

---

-   **Date**: YYYY-MM-DD <!-- User should replace with current date -->
-   **Error Description**: Inaccurate warning text in database management interface stating that custom icons would be deleted during map resets when they are actually preserved as global resources.
-   **Context/Symptoms**: 
    1. DatabaseManagement component warning text mentioned that custom icons would be deleted during map reset operations
    2. User expressed concern about custom icons being deleted during Deep Desert or Hagga Basin resets
    3. Backend verification revealed that custom icons are actually global resources NOT deleted during map resets
    4. Single combined reset button created confusion about what data would be affected for each map type
-   **Investigation/Diagnosis**:
    -   **Warning Text Analysis**: Review of DatabaseManagement component showed generic warning text that incorrectly included custom icons
    -   **Backend Code Review**: Analysis of `perform-map-reset` Edge Function confirmed it only deletes map-specific data (grid_squares, pois, comments)
    -   **Resource Classification**: Custom icons stored in `screenshots/icons/` and `custom_icons` table are global resources used across both maps
    -   **User Experience Issue**: Single reset button with generic warnings didn't provide clear information about what each map reset would affect
-   **Solution/Fix**:
    1.  **Separated Reset Functionality**: Split single reset button into dedicated Deep Desert and Hagga Basin reset buttons
    2.  **Corrected Warning Text**: Updated warning descriptions to accurately reflect what gets deleted for each map type
    3.  **Removed Custom Icons from Warnings**: Eliminated mention of custom icons being deleted since they are preserved global resources
    4.  **Enhanced Confirmation Flow**: Each reset type now requires specific confirmation text ("DELETE DEEP DESERT" vs "DELETE HAGGA BASIN")
    5.  **Backend Verification**: Confirmed that `perform-map-reset` function preserves custom icons and only deletes map-specific data
-   **Files Affected**:
    -   `src/components/admin/DatabaseManagement.tsx` (Enhanced reset functionality and corrected warnings)
    -   `src/types/admin.ts` (Updated DangerAction type for separate reset actions)
-   **Lesson Learned**: Always verify that user-facing warning text accurately reflects actual backend behavior. For admin operations involving destructive actions: (1) Clearly categorize what data is global vs scope-specific, (2) Implement separate operations for different scopes when appropriate, (3) Provide detailed, accurate descriptions of what will be affected, (4) Regularly audit warning text against actual system behavior, (5) Test destructive operations to ensure they behave as advertised to users.

---

-   **Date**: 2025-01-29
-   **Error Description**: Items & Schematics audit trail migration failures - HTTP 409 conflicts, SQL syntax errors, and column existence issues during comprehensive audit trail implementation.
-   **Context/Symptoms**: 
    1. Initial CategoryManager HTTP 409 errors during content migration due to RLS policy conflicts when updating types table globally
    2. Missing `updated_by` columns in items and schematics tables causing API failures: "Could not find the 'updated_by' column"
    3. SQL syntax errors in audit trail migration scripts with UNION statements causing "syntax error at or near UNION"
    4. Column existence errors: "column 'updated_by' does not exist" when trying to update tables before columns were added
    5. PostgreSQL refusing to execute malformed migration scripts with ambiguous column references
-   **Investigation/Diagnosis**:
    -   **Migration Sequence Issue**: Original migration scripts tried to update columns before adding them, causing existence errors
    -   **SQL Syntax Problems**: UNION ALL statements with ORDER BY clauses within individual selects violated PostgreSQL syntax rules
    -   **Column Reference Ambiguity**: Scripts assumed columns existed when they might not in different database states
    -   **RLS Policy Conflicts**: Migration operations were blocked by Row Level Security policies during global updates
    -   **Script Complexity**: Overly complex verification queries caused syntax issues and execution failures
-   **Solution/Fix**:
    1.  **Created Robust Migration Script**: Built `audit_trail_migration_final.sql` with comprehensive existence checking using DO blocks and conditional logic
    2.  **Safe Column Addition**: Used `IF NOT EXISTS` checks before adding each column to prevent duplicate column errors
    3.  **Proper SQL Syntax**: Removed all UNION statements and problematic ORDER BY clauses, replaced with simple individual SELECT statements
    4.  **Conditional Updates**: Only attempted to update existing records if both source and target columns exist
    5.  **Performance Optimization**: Added proper indexes on all new audit trail columns with conditional creation
    6.  **Documentation Enhancement**: Added column comments and comprehensive logging throughout migration process
    7.  **Cleanup Strategy**: Deleted failed migration files (`add_complete_audit_trail.sql`, `add_complete_audit_trail_fixed.sql`) to prevent confusion
-   **Files Affected**:
    -   `audit_trail_migration_final.sql` (Final working migration script)
    -   Database tables: `tiers`, `field_definitions`, `dropdown_groups`, `dropdown_options` (Enhanced with audit trail)
    -   `tasks/active_context.md`, `tasks/tasks_plan.md` (Updated to reflect completion)
-   **Lesson Learned**: For complex database migrations involving conditional schema changes: (1) Always use existence checks before adding columns or updating data, (2) Avoid UNION statements with embedded ORDER BY clauses in PostgreSQL, (3) Build migrations that are idempotent and safe to re-run, (4) Use DO blocks for conditional logic rather than assuming database state, (5) Test migration scripts incrementally rather than attempting comprehensive changes at once, (6) Clean up failed migration files immediately to prevent confusion and re-use of broken scripts, (7) Design migrations that gracefully handle missing source columns (like `created_by` not existing in some tables).

---

-   **Date**: 2025-01-30
-   **Error Description**: Tiers filtering not working due to variable scope bug in async state management callback.
-   **Context/Symptoms**: 
    1. Users reported that the tiers filter on the Items & Schematics page was not functioning correctly
    2. Other filters (categories/types) were working properly, but tier selections were not affecting displayed results
    3. Console debugging showed state changes happening correctly but filtering logic was receiving incorrect data
    4. No visible JavaScript errors in console, making the issue appear to be a logic problem rather than a runtime error
-   **Investigation/Diagnosis**:
    -   **Root Cause**: In `CategoryHierarchyNav.tsx`, the `handleTierToggle` function was incorrectly calling `updateParentFilters(localActiveView, selectedCategories, newSelectedTypes, newSelectedTiers)` where `newSelectedTypes` was undefined in that function scope
    -   **Variable Scope Error**: The function was trying to reference `newSelectedTypes` which belonged to the `handleTypeToggle` function scope, not the `handleTierToggle` function scope
    -   **Async State Issue**: This caused the parent filter update to receive incorrect type filter data when tier filtering was attempted, breaking the filtering logic
    -   **Silent Failure**: The error didn't throw exceptions but caused filtering to fail silently by passing undefined values to the parent component
-   **Solution/Fix**:
    1.  **Fixed Variable Reference**: Changed `updateParentFilters(localActiveView, selectedCategories, newSelectedTypes, newSelectedTiers)` to `updateParentFilters(localActiveView, selectedCategories, selectedTypes, newSelectedTiers)` in `handleTierToggle`
    2.  **Verified Scope**: Ensured all variables passed to `updateParentFilters` are defined in the current function scope
    3.  **End-to-End Testing**: Performed comprehensive testing to verify all filtering combinations work correctly
-   **Files Affected**:
    -   `src/components/items-schematics/CategoryHierarchyNav.tsx` (Fixed variable scope in handleTierToggle function)
-   **Lesson Learned**: When implementing complex async state management with multiple callback functions, always verify that variables referenced in callbacks are defined in the correct function scope. Variable scope errors can create silent failures that break functionality without throwing visible exceptions. Use consistent variable naming patterns and verify each callback function uses only variables from its own scope or properly passed parameters. Always test all combinations of filter interactions to catch cross-functional state management issues.

---

-   **Date**: 2025-01-30
-   **Error Description**: "Hide All" filter buttons not working - empty filter arrays treated as "skip filtering" instead of "hide all entities".
-   **Context/Symptoms**: 
    1. User reported that "Show All" toggle buttons worked correctly, but "Hide All" buttons did nothing
    2. Console logs showed filter arrays correctly becoming empty `[]` when "Hide All" was clicked
    3. Entities continued to display even when filters should have hidden everything
    4. No JavaScript errors or warnings, making it appear to be a logic issue rather than a runtime error
-   **Investigation/Diagnosis**:
    -   **Root Cause**: Filtering logic in `ItemsSchematicsContent.tsx` had conditional checks `if (filters.categories && filters.categories.length > 0)` that skipped entire filtering blocks when arrays were empty
    -   **Logic Flaw**: When "Hide All" was clicked, filter arrays became empty `[]`, causing `filters.categories.length > 0` to be false, which skipped filtering entirely instead of filtering out all entities
    -   **Pattern Issue**: The code only handled two cases: "all selected" (show all) and "some selected" (filter), but missed the third case: "none selected" (hide all)
    -   **Silent Failure**: The bug didn't throw exceptions but caused filtering to fail silently, making entities appear when they should have been hidden
-   **Solution/Fix**:
    1.  **Enhanced Category Filtering**: Changed from conditional execution to always-execute pattern:
        ```typescript
        // Before (buggy):
        if (filters.categories && filters.categories.length > 0) {
          // filtering logic only ran when array had items
        }
        
        // After (fixed):
        if (filters.categories) {
          if (filters.categories.length === 0) {
            entities = []; // Empty array = hide all
          } else {
            // normal filtering logic for non-empty arrays
          }
        }
        ```
    2.  **Applied Same Fix to Tier Filtering**: Updated tier filtering logic to handle empty arrays as "hide all" rather than "skip filtering"
    3.  **Three-Case Logic**: Now properly handles all filtering states:
        - All items selected â†’ Show all (no filtering)
        - Some items selected â†’ Show only selected items
        - No items selected (empty array) â†’ Hide all items
-   **Files Affected**:
    -   `src/components/items-schematics/ItemsSchematicsContent.tsx` (Fixed category and tier filtering logic)
-   **Lesson Learned**: When implementing toggle-based filtering systems with "Show All/Hide All" functionality: (1) Always handle empty filter arrays explicitly as "hide all" rather than "skip filtering", (2) Design filtering logic to handle three distinct states rather than just two, (3) Test all toggle combinations including the "Hide All" state which often gets overlooked, (4) Be careful with conditional filtering logic that might skip execution entirely when arrays are empty, (5) Consider using explicit state values instead of inferring behavior from array length.

---
