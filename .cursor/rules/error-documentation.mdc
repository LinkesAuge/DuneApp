---
description: Document major failure points in this project and they were solved.  To be filled by AI.
globs: 
alwaysApply: true
---
# Error Documentation: Dune Awakening Deep Desert Tracker

This document tracks known issues, their states, context, and resolutions encountered during the development of the Dune Awakening Deep Desert Tracker project.

## Format for Entries

-   **Date**: YYYY-MM-DD
-   **Error Description**: A clear summary of the error.
-   **Context/Symptoms**: How and where the error manifested.
-   **Investigation/Diagnosis**: Steps taken to understand the root cause.
-   **Solution/Fix**: The implemented solution.
-   **Files Affected**: List of files changed.
-   **Lesson Learned**: Key takeaway to prevent recurrence.

--- 

*(No errors documented yet.)*

---

-   **Date**: 2025-01-28
-   **Error Description**: POI image cropping system issues - free mode tool preselected, cropping from already-cropped images instead of originals, and missing database schema for original/cropped image handling.
-   **Context/Symptoms**: 
    1. When opening POI edit modal for image cropping, "Free Form" tool was automatically preselected when user wanted no tool active by default
    2. When editing existing POI images that were previously cropped, subsequent crops were applied to the already-cropped image instead of the original image
    3. Original images were being lost during the upload/crop workflow because only cropped versions were saved
    4. Database schema was missing `original_url` and `crop_details` fields in PoiScreenshot interface, causing TypeScript errors and runtime issues
-   **Investigation/Diagnosis**:
    -   **Tool Preselection**: ImageCropModal was using `aspect=undefined` for "no tool active" state, but this was being interpreted as "Free Form" active. Needed a distinct state for "no tool selected".
    -   **Original Image Loss**: The `PendingScreenshotFile` interface only stored the final processed file, losing the original when cropping was applied. When editing existing screenshots, the system tried to access `original_url` but this field wasn't properly stored.
    -   **Database Schema Gap**: The PoiScreenshot interface was missing `original_url` and `crop_details` fields that the code was trying to use, creating a mismatch between implementation and types.
    -   **Upload Workflow Flaw**: The current workflow immediately replaced the original file with the cropped version, making it impossible to re-crop from the original or store both versions properly.
-   **Solution/Fix**:
    1.  **Fixed Tool Selection State Management**: Modified ImageCropModal to use `aspect=null` for "no tool active", `aspect=undefined` for "Free Form", and `aspect=1` for "Square Mode". Updated button styling logic accordingly.
    2.  **Enhanced Database Schema**: Added `original_url?: string | null` and `crop_details?: PixelCrop | null` fields to PoiScreenshot interface with proper import from 'react-image-crop'.
    3.  **Redesigned Upload Workflow**: Completely overhauled the PendingScreenshotFile interface to store both `originalFile` and `displayFile`, preserving the original throughout the entire workflow.
    4.  **Fixed Upload Logic**: Modified the upload process to save both original and display versions to separate storage paths (`poi_originals/` and `poi_screenshots/`) with proper URL references.
    5.  **Improved Image Preview**: Changed ImageCropModal image constraint from `max-h-[60vh]` to `max-h-full` to better utilize available space for tall images.
-   **Files Affected**:
    -   `src/components/grid/ImageCropModal.tsx` (Tool selection state and image sizing)
    -   `src/types/index.ts` (Enhanced PoiScreenshot interface)
    -   `src/components/hagga-basin/POIEditModal.tsx` (Complete workflow overhaul)
-   **Lesson Learned**: When implementing image cropping systems: (1) Always preserve original files separately from processed versions, (2) Use distinct state values for different UI modes rather than relying on undefined/truthy checks, (3) Ensure database schema matches the data structures used in code, (4) Design upload workflows to handle both original and processed versions from the start rather than retrofitting later, (5) Test image cropping workflows with both new uploads and editing existing images to catch different code paths.

---

-   **Date**: YYYY-MM-DD <!-- User should replace with current date -->
-   **Error Description**: Supabase Storage `listBuckets()` returns empty array `[]` and `getBucket('bucket-name')` fails with "Bucket not found" (400 error) for a newly created, public bucket, despite the bucket existing in the Supabase dashboard and client being authenticated.
-   **Context/Symptoms**: Occurred in `PoiTypeManager.tsx` when attempting to interact with a new 'poi-icons' bucket for icon uploads. Another existing bucket ('screenshots') was working for other functionalities. SQL grants for `SELECT` on `storage.buckets` to `authenticated` and `anon` roles did not resolve the issue. No restrictive RLS policies were found on `storage.buckets` table itself.
-   **Investigation/Diagnosis**:
    -   Verified bucket existence and public status in Supabase dashboard.
    -   Confirmed client-side Supabase initialization and user authentication.
    -   Ran `supabase.storage.listBuckets()` directly in component, consistently received `[]`.
    -   Ran `supabase.storage.getBucket('poi-icons')`, received 400 error.
    -   Applied various SQL `GRANT` statements for `storage.buckets`, `storage.objects`, `storage.migrations` and `USAGE` on `storage` schema to `authenticated` and `anon` roles.
    -   Checked for RLS policies on `storage.buckets` (none found).
    -   The exact root cause for `listBuckets()` returning empty for a specific, seemingly correctly configured bucket remained elusive, suggesting potential subtle configuration issues or caching on Supabase's side that weren't immediately apparent.
-   **Solution/Fix**: 
    1.  Decided to use an existing, functional bucket ('screenshots') and create a dedicated subfolder ('icons/') within it for POI icons.
    2.  Refactored `PoiTypeManager.tsx` to upload icons to `screenshots/icons/` and removed direct calls to `listBuckets()` or `getBucket()` that were causing issues, relying on known bucket and path.
-   **Files Affected**:
    -   `src/components/admin/PoiTypeManager.tsx` (Primary change to use different bucket/path and remove failing Storage calls)
    -   Initially, SQL scripts for creating 'poi-icons' bucket and its policies (later made redundant by the workaround).
-   **Lesson Learned**: When encountering unexplained issues with new Supabase Storage buckets (especially `listBuckets()` or `getBucket()`), and if an existing bucket is functional, consider using a subfolder within the working bucket as a pragmatic workaround to avoid prolonged debugging of potential platform-side intricacies. Always verify RLS policies and grants thoroughly, but be prepared for alternative strategies if issues persist.

---

-   **Date**: YYYY-MM-DD <!-- User should replace with current date -->
-   **Error Description**: `pg_cron` job fails to trigger Supabase Edge Function; `cron.job_run_details` shows `return_message` like "ERROR: schema \"net\" does not exist".
-   **Context/Symptoms**: Scheduled tasks (e.g., `perform-map-backup`) that rely on `pg_cron` to call a Supabase Edge Function via `net.http_post` were not executing the function. The cron job itself might appear to run, but the target function logs no invocations.
-   **Investigation/Diagnosis**:
    -   Checked `cron.job` for job definition and `cron.job_run_details` for execution status and return messages.
    -   The error "schema \"net\" does not exist" in `return_message` clearly indicated the `pg_net` PostgreSQL extension was missing or not enabled.
    -   Verified in Supabase Dashboard under Database > Extensions that `pg_net` was not listed or not enabled.
-   **Solution/Fix**:
    1.  Enabled the `pg_net` extension by running the following SQL in the Supabase SQL Editor:
        ```sql
        CREATE EXTENSION IF NOT EXISTS pg_net WITH SCHEMA extensions;
        ```
-   **Files Affected**: None (Database configuration change).
-   **Lesson Learned**: `pg_net` is a critical dependency for `pg_cron` to trigger Supabase Edge Functions using `net.http_post`. If scheduled function invocations fail, always check `cron.job_run_details` for errors and ensure `pg_net` is enabled in the database. Add this to `docs/technical.md`.

---

-   **Date**: YYYY-MM-DD <!-- User should replace with current date -->
-   **Error Description**: User deletion via Supabase Edge Function (`delete-user`) calling `supabase.auth.admin.deleteUser()` failed with the error "Failed to delete user from authentication: Database error deleting user".
-   **Context/Symptoms**: Occurred in the Admin Panel when attempting to delete a user. The Edge Function logs showed the error originating from the `deleteUser()` call.
-   **Investigation/Diagnosis**:
    -   Initial assumption was a direct issue with the `auth.users` table or the `deleteUser` admin function.
    -   Used SQL to query `pg_constraint` to identify foreign key relationships involving `auth.users`.
    -   Discovered that `public.profiles.id` had a foreign key constraint (`profiles_id_fkey`) referencing `auth.users(id)` with an `ON DELETE NO ACTION` policy. This prevented the `auth.users` row from being deleted because a dependent row existed in `public.profiles`.
    -   Further checked for foreign keys referencing `public.profiles(id)` from other tables (e.g., `pois`, `grid_squares`) to ensure no further downstream blocking issues once the `profiles` row was deleted. In this case, no further blocking constraints were found on other public tables.
-   **Solution/Fix**:
    1.  Modified the `profiles_id_fkey` constraint on the `public.profiles` table to use `ON DELETE CASCADE`.
        ```sql
        -- 1. Drop the existing constraint
        ALTER TABLE public.profiles
        DROP CONSTRAINT profiles_id_fkey;

        -- 2. Add it back with ON DELETE CASCADE
        ALTER TABLE public.profiles
        ADD CONSTRAINT profiles_id_fkey FOREIGN KEY (id)
        REFERENCES auth.users (id) ON DELETE CASCADE;
        ```
-   **Files Affected**:
    -   Database schema (constraint modification).
    -   `docs/technical.md` (updated to document this common issue and solution).
-   **Lesson Learned**: When deleting from `auth.users` in Supabase, always verify the `ON DELETE` action of any foreign key constraints in `public` tables (especially `public.profiles`) that reference `auth.users.id`. `NO ACTION` or `RESTRICT` will cause deletion failures. Change to `CASCADE` or `SET NULL` as appropriate for the data model. Also, check for chained dependencies if other tables reference the `profiles` table.

---

-   **Date**: YYYY-MM-DD <!-- User should replace with current date -->
-   **Error Description**: Scheduled map reset (with "backup before reset" enabled) successfully performed the backup but then failed to delete data from `pois` and `grid_squares` tables.
-   **Context/Symptoms**: The Supabase Edge Function log for `perform-map-reset` showed the error: `Failed to delete POIs: invalid input syntax for type uuid: "0"`. This occurred because the delete operation was attempting `supabaseAdmin.from('pois').delete().neq('id', '0')` where the `id` column is of type UUID, and '0' is not a valid UUID string.
-   **Investigation/Diagnosis**: Examined the `perform-map-reset/index.ts` function. Identified the `.neq('id', '0')` filter in the delete operations for both `pois` and `grid_squares` tables as the cause of the type mismatch.
-   **Solution/Fix**: Modified `supabase/functions/perform-map-reset/index.ts`. Changed the Supabase query filter for deleting records from `.delete().neq('id', '0')` to `.delete().not('id', 'is', null)` for both `pois` and `grid_squares` tables. This provides a type-safe way to target all rows for deletion, assuming the `id` column is a primary key and thus never null for existing rows.
-   **Files Affected**:
    -   `supabase/functions/perform-map-reset/index.ts`
-   **Lesson Learned**: When attempting to delete all rows in a table using the Supabase query builder with a filter (e.g., `.delete().filter(...)`), ensure the filter condition is type-compatible with the column(s) involved. For UUID primary keys, using a condition like `.not('id', 'is', null)` is a robust and type-safe method to target all rows for deletion. Avoid direct string comparisons with UUID columns unless the string is a valid UUID.

---

-   **Date**: 2025-01-03
-   **Error Description**: Custom icons not displaying on map - POIs showed custom icons in edit modals but reverted to default POI type icons (emojis) when displayed on the map.
-   **Context/Symptoms**: 
    -   Console logs showed MapPOIMarker receiving emoji icons ("🔰", "🔲", "🛡️") instead of custom icon UUIDs
    -   POIEditModal correctly processed custom icon selection (UUID: "888361ee-62fd-4b50-b408-cd00644b86b8")
    -   Custom icon selections didn't persist through database operations and component re-renders
    -   Map components consistently showed POI type default icons instead of user-selected custom icons
-   **Investigation/Diagnosis**:
    -   Root cause identified as client-side data modification approach in POI modals
    -   POIEditModal and POIPlacementModal were temporarily modifying POI type data client-side
    -   Database operations saved POI records without custom icon references
    -   Map components received POI data through database queries, losing client-side modifications
    -   This created a disconnect between edit interface (showing custom icons) and display interface (showing defaults)
-   **Solution/Fix**:
    1.  **Database Schema Enhancement**: Added `custom_icon_id uuid` column to `pois` table with foreign key to `custom_icons(id)` and `ON DELETE SET NULL`
    2.  **TypeScript Interface Update**: Modified `Poi` interface to include `custom_icon_id: string | null`
    3.  **Component Logic Overhaul**: Updated all POI-related components to use database-first approach:
        -   **MapPOIMarker**: Modified `getDisplayImageUrl` to check POI's `custom_icon_id` first, then POI type defaults
        -   **POIEditModal & POIPlacementModal**: Changed from client-side override to database persistence, saving `custom_icon_id` directly
        -   **HaggaBasinPoiCard**: Updated icon rendering to use same priority logic as MapPOIMarker
        -   **PoiCard**: Added `customIcons` prop and updated icon rendering for Deep Desert POIs
        -   **PoiList**: Added `customIcons` prop passthrough to PoiCard
        -   **GridSquareModal**: Added custom icons fetching and state management
    4.  **Database Migration**: Created and executed migration script with indexing for performance
-   **Files Affected**:
    -   Database: `add_custom_icon_id_column.sql`
    -   Types: `src/types/index.ts`
    -   Map Components: `src/components/hagga-basin/MapPOIMarker.tsx`
    -   Edit Modals: `src/components/poi/POIEditModal.tsx`, `src/components/poi/POIPlacementModal.tsx`
    -   Display Components: `src/components/hagga-basin/HaggaBasinPoiCard.tsx`, `src/components/poi/PoiCard.tsx`, `src/components/poi/PoiList.tsx`, `src/components/grid/GridSquareModal.tsx`
-   **Lesson Learned**: For persistent user selections that need to survive database operations and component re-renders, always use a database-first approach rather than client-side data modification. Client-side overrides are fragile and don't persist through data refresh cycles. Database persistence with proper foreign key relationships ensures data integrity and consistent display across all application interfaces.

---

-   **Date**: 2025-01-03
-   **Error Description**: POI filter All/None toggle buttons not working correctly - "Hide All" would briefly hide POIs but immediately show them again, and overall filtering logic was inconsistent.
-   **Context/Symptoms**: 
    -   User reported that All/None filter buttons still didn't work after previous attempts to fix them
    -   "Hide All" button would update the UI but POIs would remain visible on the map
    -   Console debugging showed state changes happening correctly but visual results were wrong
    -   Toggle button text was updating properly but actual POI visibility wasn't responding
-   **Investigation/Diagnosis**:
    -   **Root Cause 1 - Filtering Logic Bug**: The condition `if (selectedPoiTypes.length > 0 && !selectedPoiTypes.includes(poi.poi_type_id))` had a fatal flaw:
        - When `selectedPoiTypes` was empty (Hide All state), the first part `selectedPoiTypes.length > 0` was false
        - This made the entire condition false, causing all POIs to be shown instead of hidden
        - The logic was backwards for the "Hide All" scenario
    -   **Root Cause 2 - State Management Conflict**: A useEffect was automatically re-selecting all POI types whenever `selectedPoiTypes.length === 0`:
        - This was intended for initial page load setup but triggered on every state change
        - When user clicked "Hide All" → `selectedPoiTypes` became empty → useEffect immediately refilled it → user action was undone
        - Created a race condition between user actions and automatic state management
-   **Solution/Fix**:
    1.  **Fixed Core Filtering Logic**: Changed condition to `if (!selectedPoiTypes.includes(poi.poi_type_id))`:
        - Simplified logic that works correctly for both show and hide scenarios
        - When `selectedPoiTypes` is empty → no POIs pass the filter → all hidden (correct)
        - When `selectedPoiTypes` has values → only included POIs pass → only selected shown (correct)
    2.  **Fixed State Management**: Added `initialFilterSetup` flag to control useEffect:
        - Effect only runs once on initial page load when `!initialFilterSetup`
        - Prevents interference with user actions after initial setup
        - Preserves user's filter choices without automatic override
    3.  **Console Cleanup**: Removed debug logs from `useMapSettings`, `SignInForm`, and `supabase.ts` for production readiness
-   **Files Affected**:
    -   `src/pages/HaggaBasinPage.tsx` (Primary fix - filtering logic and state management)
    -   `src/lib/useMapSettings.ts` (Removed console logs)
    -   `src/components/auth/SignInForm.tsx` (Removed console logs)
    -   `src/lib/supabase.ts` (Removed console logs)
-   **Lesson Learned**: Complex filtering logic with multiple conditions can create edge cases where the logic works for some scenarios but fails for others. When debugging filter systems: (1) Test all possible states including empty selections, (2) Watch for useEffect hooks that might interfere with user actions, (3) Simplify filtering conditions to avoid edge case failures, (4) Use state flags to control when automatic effects should run vs. when user actions should take precedence. Always verify that "hide all" and "show all" scenarios work correctly in filtering systems.

---

-   **Date**: 2025-01-28
-   **Error Description**: POI image cropping modal issues - square mode preselected when editing images and tall images getting cut off in preview.
-   **Context/Symptoms**: 
    -   When editing already cropped POI images (especially those with height > width), the square cropping tool was automatically preselected
    -   Tall images appeared very small or "cut off" in the cropping modal preview, making it difficult to see and select the desired crop area
    -   Users expected no cropping tool to be preselected by default when editing POI images
    -   The preview area wasn't utilizing available space efficiently for tall images
-   **Investigation/Diagnosis**:
    -   **Root Cause 1 - Square Mode Preselection**: In `POIEditModal.tsx`, the `ImageCropModal` was called with `defaultToSquare={true}`, automatically activating square mode regardless of user preference
    -   **Root Cause 2 - Image Preview Height Constraint**: In `ImageCropModal.tsx`, the image had CSS class `max-h-[60vh]` which limited height to 60% of viewport height. For tall images, this constraint was too restrictive given the available space in the modal's image area
    -   The modal itself was `max-h-[90vh]` and the image area used `flex-grow`, but the fixed 60vh limit on the image prevented it from using the full available space
-   **Solution/Fix**:
    1.  **Fixed Square Mode Preselection**: Changed `defaultToSquare={true}` to `defaultToSquare={false}` in `POIEditModal.tsx` line 1000
    2.  **Improved Image Preview Sizing**: Changed image CSS from `max-h-[60vh]` to `max-h-full` in `ImageCropModal.tsx` line 391, allowing images to use the full height of their flex container
    -   This allows tall images to display much larger while still fitting within the modal's responsive layout
    -   The flex container with `flex-grow` and `overflow-hidden` properly constrains the image to available space
-   **Files Affected**:
    -   `src/components/hagga-basin/POIEditModal.tsx` (Changed defaultToSquare prop)
    -   `src/components/grid/ImageCropModal.tsx` (Improved image sizing CSS)
-   **Lesson Learned**: When implementing cropping modals: (1) Don't preselect cropping tools unless there's a specific business requirement - let users choose their preferred method, (2) Use flexible CSS constraints (like `max-h-full`) that work with flex layouts rather than fixed viewport units that may not utilize available space efficiently, (3) Consider the aspect ratio and available space when constraining image previews - tall images need more height allowance than fixed vh units typically provide.

---
